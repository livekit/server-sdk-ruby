# Code generated by protoc-gen-twirp_ruby 1.0.0, DO NOT EDIT.
# source: livekit_egress.proto

require "json"
require "net/https"
require "google/protobuf"

module Livekit
  class Error < StandardError; end

  class ServiceError < Error
    attr_reader :code
    attr_reader :meta
    attr_reader :message

    def initialize(response)
      error = JSON.parse(response.body)

      @code    = error["code"]
      @meta    = error["meta"] || {}
      @message = error["msg"]
    end
  end

  RoomCompositeEgressRequest ||= ::Google::Protobuf::DescriptorPool.generated_pool.lookup("livekit.RoomCompositeEgressRequest").msgclass
  TrackCompositeEgressRequest ||= ::Google::Protobuf::DescriptorPool.generated_pool.lookup("livekit.TrackCompositeEgressRequest").msgclass
  TrackEgressRequest ||= ::Google::Protobuf::DescriptorPool.generated_pool.lookup("livekit.TrackEgressRequest").msgclass
  EncodedFileOutput ||= ::Google::Protobuf::DescriptorPool.generated_pool.lookup("livekit.EncodedFileOutput").msgclass
  SegmentedFileOutput ||= ::Google::Protobuf::DescriptorPool.generated_pool.lookup("livekit.SegmentedFileOutput").msgclass
  DirectFileOutput ||= ::Google::Protobuf::DescriptorPool.generated_pool.lookup("livekit.DirectFileOutput").msgclass
  S3Upload ||= ::Google::Protobuf::DescriptorPool.generated_pool.lookup("livekit.S3Upload").msgclass
  GCPUpload ||= ::Google::Protobuf::DescriptorPool.generated_pool.lookup("livekit.GCPUpload").msgclass
  AzureBlobUpload ||= ::Google::Protobuf::DescriptorPool.generated_pool.lookup("livekit.AzureBlobUpload").msgclass
  StreamOutput ||= ::Google::Protobuf::DescriptorPool.generated_pool.lookup("livekit.StreamOutput").msgclass
  EncodingOptions ||= ::Google::Protobuf::DescriptorPool.generated_pool.lookup("livekit.EncodingOptions").msgclass
  UpdateLayoutRequest ||= ::Google::Protobuf::DescriptorPool.generated_pool.lookup("livekit.UpdateLayoutRequest").msgclass
  UpdateStreamRequest ||= ::Google::Protobuf::DescriptorPool.generated_pool.lookup("livekit.UpdateStreamRequest").msgclass
  ListEgressRequest ||= ::Google::Protobuf::DescriptorPool.generated_pool.lookup("livekit.ListEgressRequest").msgclass
  ListEgressResponse ||= ::Google::Protobuf::DescriptorPool.generated_pool.lookup("livekit.ListEgressResponse").msgclass
  StopEgressRequest ||= ::Google::Protobuf::DescriptorPool.generated_pool.lookup("livekit.StopEgressRequest").msgclass
  EgressInfo ||= ::Google::Protobuf::DescriptorPool.generated_pool.lookup("livekit.EgressInfo").msgclass
  StreamInfoList ||= ::Google::Protobuf::DescriptorPool.generated_pool.lookup("livekit.StreamInfoList").msgclass
  StreamInfo ||= ::Google::Protobuf::DescriptorPool.generated_pool.lookup("livekit.StreamInfo").msgclass
  FileInfo ||= ::Google::Protobuf::DescriptorPool.generated_pool.lookup("livekit.FileInfo").msgclass
  SegmentsInfo ||= ::Google::Protobuf::DescriptorPool.generated_pool.lookup("livekit.SegmentsInfo").msgclass
  AutoTrackEgress ||= ::Google::Protobuf::DescriptorPool.generated_pool.lookup("livekit.AutoTrackEgress").msgclass
  

  
  class EgressClient
    attr_reader :service_name

    def initialize(server)
      @server       = URI.parse(server)
      @service_name = "livekit.Egress"
    end

    
    def start_room_composite_egress(room_composite_egress_request)
      body = room_composite_egress_request.to_proto
      resp = make_request(body, "#{service_name}/StartRoomCompositeEgress")

      EgressInfo.decode(resp.body)
    end
    
    def start_track_composite_egress(track_composite_egress_request)
      body = track_composite_egress_request.to_proto
      resp = make_request(body, "#{service_name}/StartTrackCompositeEgress")

      EgressInfo.decode(resp.body)
    end
    
    def start_track_egress(track_egress_request)
      body = track_egress_request.to_proto
      resp = make_request(body, "#{service_name}/StartTrackEgress")

      EgressInfo.decode(resp.body)
    end
    
    def update_layout(update_layout_request)
      body = update_layout_request.to_proto
      resp = make_request(body, "#{service_name}/UpdateLayout")

      EgressInfo.decode(resp.body)
    end
    
    def update_stream(update_stream_request)
      body = update_stream_request.to_proto
      resp = make_request(body, "#{service_name}/UpdateStream")

      EgressInfo.decode(resp.body)
    end
    
    def list_egress(list_egress_request)
      body = list_egress_request.to_proto
      resp = make_request(body, "#{service_name}/ListEgress")

      ListEgressResponse.decode(resp.body)
    end
    
    def stop_egress(stop_egress_request)
      body = stop_egress_request.to_proto
      resp = make_request(body, "#{service_name}/StopEgress")

      EgressInfo.decode(resp.body)
    end
    

    def make_request(body, path)
      options = {
        use_ssl: @server.scheme == "https",
      }

      Net::HTTP.start(@server.host, @server.port, options) do |http|
        path    = "/twirp/#{path}"
        request = Net::HTTP::Post.new(path)
        request.body = body

        request["User-Agent"]   = user_agent
        request["Content-Type"] = "application/protobuf"

        # Authenticate with Basic Auth if a username or password was provided.
        if @server.user || @server.password
          request.basic_auth(url.user, url.password)
        end

        response = http.request(request)

        if !response.is_a?(Net::HTTPSuccess)
          raise ServiceError.new(response)
        end

        response
      end
    end

    def user_agent
      "#{RUBY_ENGINE}/#{RUBY_VERSION}; #{RUBY_PLATFORM}; v1.0.0"
    end
  end
  
end
